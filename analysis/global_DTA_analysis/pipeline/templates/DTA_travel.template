<?xml version="1.0" standalone="yes"?>

<!-- Generated by BEAUTi v1.8.0 Prerelease r5934                             -->
<!--       by Alexei J. Drummond, Andrew Rambaut and Marc A. Suchard         -->
<!--       Department of Computer Science, University of Auckland and        -->
<!--       Institute of Evolutionary Biology, University of Edinburgh        -->
<!--       David Geffen School of Medicine, University of California, Los Angeles-->
<!--       http://beast.bio.ed.ac.uk/                                        -->
<beast>
<#-- Settings and other parameters. Some of which can be provided at commandline -->
<#setting number_format="computer">
<#assign outputFileStem = outputFileStem!"DTA">
<#assign chainLength = chainLength!1000000000>
<#assign logEvery = logEvery!chainLength/10000>
<#assign empTreeFile = empTreeFile>
<#assign discreteTraits=(states!"location")?split("|")>


<#-- A function to extract an entry out of an array based on that entry's id -->
<#function extractElement array id>
    <#local foundIt="NotFound">
  <#list array as element >
	<#if element.id == id>
	<#local foundIt = element>
	</#if>
  </#list>
  <#return foundIt>
</#function>

<#-- get the matrix with 0's on the diagnol -->
<#function getCountMatrix n>
	<#local string = " ">
	<#local c = 1>
	<#local totalEntries = n*n>
	<#local entrySequence = 1..totalEntries>
	<#list entrySequence as i>
		<#if i % n ==c >
				<#local string = string + "0.0 ">
		<#elseif i == totalEntries>
			<#local string = string + "0.0 ">
		<#else>
			<#local string = string + "1.0 ">
			<#if i %n ==0>
				<#local c = c+1>
			</#if>
		</#if>
	</#list>
	<#return string>
	
</#function>


	<!-- The list of taxa to be analysed (can also include dates/ages).          -->
	<!-- ntax=${taxa?size}                                               -->
	<taxa id="taxa">	
	<#list taxa as taxon>
		<taxon id="${taxon.id}">
			<date value="${taxon.date}" direction="forwards" units="years" uncertainty="${taxon.uncertainty}"/>
			<#list taxon.attributes as attr>
				<#if discreteTraits?seq_contains(attr.id)>
			<attr name="${attr.id}">
				${attr.value}
			</attr>
				</#if>
			</#list>        
		</taxon>
	</#list> 
	</taxa>


    <!-- Travel history: defining ancestral node taxa with their discrete trait state -->
    <taxa id="ancestralTaxa">
        <#list taxa as taxon>
           <#assign location = extractElement(taxon.attributes, "travel_history")>
           <#if location.value!="\"NA\"" && location.value!="NA">
		<taxon id="${taxon.id}_ancestor">
			<attr name="location">
				${location.value}
			</attr>
		</taxon>
            </#if>
	</#list> 
    </taxa>

    <taxa id="allTaxa">
        <taxa idref="taxa"/>
        <taxa idref="ancestralTaxa"/>
    </taxa>

	<empiricalTreeDistributionModel id="treeModel" fileName="${empTreeFile}">
		<taxa idref="taxa"/>
	</empiricalTreeDistributionModel>
	
	<statistic id="treeModel.currentTree" name="Current Tree">
		<empiricalTreeDistributionModel idref="treeModel"/>
	</statistic>
	
	<!-- START Discrete Traits Model                                             -->
<!-- TODO for each attribute -->
	<#list discreteTraits as trait>
		<#assign thisTrait = extractElement(taxaAttributes,trait)>
	<!-- general data type for discrete trait model, '${trait}'                      -->
	<generalDataType id="${trait}.dataType">
		<!-- Number Of States = ${thisTrait.values?size}                                                   -->
			<#list thisTrait.values as value>
			<#if value!="IndiaOrGlobal" && value!="NA" && value!="\"NA\"" >
		<state code="${value}"/>
			</#if>
			</#list>
		<ambiguity code="IndiaOrGlobal" states="India Global"/>
	</generalDataType>

	<!-- Data pattern for discrete trait, '${trait}'                                -->
	<attributePatterns id="${trait}.pattern" attribute="${trait}">
		<taxa idref="allTaxa"/>
		<generalDataType idref="${trait}.dataType"/>
	</attributePatterns>

	</#list>

	<!-- END Discrete Traits Model                                               -->
	
	<!-- The strict clock (Uniform rates across branches)                        -->
	<!-- TODO for each attribute -->
	<!-- The strict clock (Uniform rates across branches)                        -->
	<#list discreteTraits as trait>
	<#assign thisTrait = extractElement(taxaAttributes,trait)>
	<strictClockBranchRates id="${trait}.branchRates">
		<rate>
			<parameter id="${trait}.clock.rate" value="1.0" lower="0.0"/>
		</rate>
	</strictClockBranchRates>

	</#list> 
	
		<!-- START Discrete Traits Model                                             -->

	<#list discreteTraits as trait>
		<#assign thisTrait = extractElement(taxaAttributes,trait)>
		<#assign numberOfStates = thisTrait.values?size>
		<#assign dimensions = ((numberOfStates*numberOfStates)-numberOfStates)/2>
	<!-- asymmetric CTMC model for discrete state reconstructions                 -->
	<generalSubstitutionModel id="${trait}.model">
		<generalDataType idref="${trait}.dataType"/>
		
		<frequencies>
			<frequencyModel id="${trait}.frequencyModel" normalize="true">
				<generalDataType idref="${trait}.dataType"/>
				<frequencies>
					<parameter id="${trait}.frequencies" dimension="${numberOfStates}"/>
				</frequencies>
			</frequencyModel>
		</frequencies>

		<!-- rates and indicators                                                    -->
		
		<rates>
			<parameter id="${trait}.rates" dimension="${numberOfStates*2}" value="1.0"/>
		</rates>
		<rateIndicator>
			<parameter id="${trait}.indicators" dimension="${numberOfStates*2}" value="1.0"/>
		</rateIndicator>

	</generalSubstitutionModel>
	<sumStatistic id="${trait}.nonZeroRates" elementwise="true">
		<parameter idref="${trait}.indicators"/>
	</sumStatistic>
	<productStatistic id="${trait}.actualRates" elementwise="false">
		<parameter idref="${trait}.indicators"/>
		<parameter idref="${trait}.rates"/>
	</productStatistic>
	<siteModel id="${trait}.siteModel">
		<substitutionModel>
			<generalSubstitutionModel idref="${trait}.model"/>
		</substitutionModel>
	</siteModel>

	</#list>
	<!-- END Discrete Traits Model                                               -->
		<!-- Travel history: defining ancestral trait tree model: in this case times are defined since the tip height (relativeToTipHeight="true") -->
    <ancestralTraitTreeModel id="ancestralTraitTreeModel">
        <treeModel idref="treeModel"/>
    <#list taxa as taxon>
           <#assign location = extractElement(taxon.attributes, "travel_history")>
           <#if location.value!="\"NA\"" && location.value!="NA">
        <ancestor>
		<taxon idref="${taxon.id}_ancestor"/>
		<parameter id="pseudoBranchLength-${taxon.id}" value="0.000" lower="0.0"/>
        <ancestralPath relativeToTipHeight="true">
            <taxon idref="${taxon.id}"/>
            <parameter id="time-${taxon.id}" lower="0.0" value=" 0.01917808"/> <!--7 days -->
        </ancestralPath>
        </ancestor>
            </#if>
	</#list> 
    </ancestralTraitTreeModel>



	<!--  Likelihood for tree given sequence data                                 -->
<!-- For each trait for each tree -->
	<#list discreteTraits as trait>
	<#assign thisTrait = extractElement(taxaAttributes,trait)>
	<#assign numberOfStates = thisTrait.values?size>
	<#assign dimensions = ((numberOfStates*numberOfStates)-numberOfStates)/2>
	<markovJumpsTreeLikelihood id="${trait}.treeLikelihood" useAmbiguities="true" useUniformization="true" numberOfSimulants="1" stateTagName="${trait}" saveCompleteHistory="false" logCompleteHistory="false" conditionalProbabilitiesInLogSpace="true">
		<attributePatterns idref="${trait}.pattern"/>
        <ancestralTraitTreeModel idref="ancestralTraitTreeModel"/>
		<siteModel idref="${trait}.siteModel"/>
		<generalSubstitutionModel idref="${trait}.model"/>
		<strictClockBranchRates idref="${trait}.branchRates"/>
		<!-- The root state frequencies                                              -->
		<frequencyModel id="${trait}.root.frequencyModel" normalize="true">
			<generalDataType idref="${trait}.dataType"/>
			<frequencies>
				<parameter id="${trait}.root.frequencies" dimension="${numberOfStates}"/>
			</frequencies>
		</frequencyModel>
		<!-- START Ancestral state reconstruction                                    -->
		<parameter id="${trait}.count" value="${getCountMatrix(thisTrait.values?size)}"/>
		<!-- END Ancestral state reconstruction                                      -->
	</markovJumpsTreeLikelihood>
	
	
	
	</#list>
	
	<!-- Define operators                                                        -->
	<operators id="operators" optimizationSchedule="log">
		<empiricalTreeDistributionOperator weight="4">
			<empiricalTreeDistributionModel idref="treeModel"/>
		</empiricalTreeDistributionOperator>

		
		<!-- TODO dicsrete model operators scale operator on each discrete trait model -->
		<#list discreteTraits as trait>
		<scaleOperator scaleFactor="0.75" weight="3">
			<parameter idref="${trait}.clock.rate"/>
		</scaleOperator>

		<scaleOperator scaleFactor="0.75" weight="15" scaleAllIndependently="true">
			<parameter idref="${trait}.rates"/>
		</scaleOperator>
		<!-- <bitFlipOperator weight="3">
			<parameter idref="${trait}.indicators"/>
		</bitFlipOperator> -->
		<deltaExchange delta="0.75" weight="1">
			<parameter idref="${trait}.root.frequencies"/>
		</deltaExchange>
		</#list>
<!-- END discrete model operator-->
		
		
		
	</operators>
	
	
	<!-- Define MCMC                                                             -->
	<!-- <mcmc id="mcmc" chainLength="5000000" autoOptimize="true" operatorAnalysis="${outputFileStem}.ops"> -->
	<mcmc id="mcmc" chainLength="625000" autoOptimize="true" operatorAnalysis="${outputFileStem}.ops">

		<joint id="joint">
			<prior id="prior">
				
				
			<#list discreteTraits as trait>
			<#assign thisTrait = extractElement(taxaAttributes,trait)>
			<#assign numberOfStates = thisTrait.values?size>
			<#assign dimensions = ((numberOfStates*numberOfStates)-numberOfStates)/2>

				<gammaPrior shape="0.001" scale="1000.0" offset="0.0">
					<parameter idref="${trait}.clock.rate"/>
				</gammaPrior>

			<!-- TODO verify this prior-->
				<poissonPrior mean="0.6931471805599453" offset="${numberOfStates-1}">
					<statistic idref="${trait}.nonZeroRates"/>
				</poissonPrior>
				<uniformPrior lower="0.0" upper="1.0">
					<parameter idref="${trait}.frequencies"/>
				</uniformPrior>
				<uniformPrior lower="0.0" upper="1.0">
					<parameter idref="${trait}.root.frequencies"/>
				</uniformPrior>

<!-- 
				<uniformPrior lower="0.0" upper = "${dimensions}">
					<statistic idref="${trait}.nonZeroRates"/>
				</uniformPrior>
 -->
				<cachedPrior>
					<gammaPrior shape="1.0" scale="1.0" offset="0.0">
						<parameter idref="${trait}.rates"/>
					</gammaPrior>
					<parameter idref="${trait}.rates"/>
				</cachedPrior>
			
				<generalSubstitutionModel idref="${trait}.model"/>
				<strictClockBranchRates idref="${trait}.branchRates"/>

<!-- END discrete models -->
				</#list>
								
			</prior>	
			<likelihood id="likelihood">
				<!-- START Discrete Traits Model                                           -->
				<#list discreteTraits as trait>  
				<markovJumpsTreeLikelihood idref="${trait}.treeLikelihood"/>
				</#list>
				<!-- END Discrete Traits Model                                               -->
			</likelihood>
		</joint>
		<operators idref="operators"/>

		
		<!-- write log to screen                                                     -->
		<log id="screenLog" logEvery="2500">
			<column label="Joint" dp="4" width="12">
				<joint idref="joint"/>
			</column>
			<column label="Prior" dp="4" width="12">
				<prior idref="prior"/>
			</column>
			<column label="Likelihood" dp="4" width="12">
				<likelihood idref="likelihood"/>
			</column>
			<#list discreteTraits as trait>
			<#assign thisTrait = extractElement(taxaAttributes,trait)>
			<column label="${trait}.clock.rate" sf="6" width="12">
				<parameter idref="${trait}.clock.rate"/>
			</column>
			<column label="${trait}.nonZeroRates" sf="6" width="12">
				<sumStatistic idref="${trait}.nonZeroRates"/>
			</column>

			</#list>
			<column label="Tree#" dp="0" width="12">
				<statistic idref="treeModel.currentTree"/>
			</column>

		</log>
	<!-- write log to file                                                       -->
		<log id="fileLog" logEvery="500" fileName="${outputFileStem}.log" overwrite="false">
			<joint idref="joint"/>
			<prior idref="prior"/>
			<likelihood idref="likelihood"/>
			<statistic idref="treeModel.currentTree"/>

<!-- START Discrete Traits Model                                             -->
		<#list discreteTraits as trait>
		<#assign thisTrait = extractElement(taxaAttributes,trait)>			
			<parameter idref="${trait}.clock.rate"/>
			<parameter idref="${trait}.rates"/>
			<parameter idref="${trait}.indicators"/>
			<sumStatistic idref="${trait}.nonZeroRates"/>
			<!-- <parameter idref="${trait}.root.frequencies"/>
			<parameter idref="${trait}.frequencies"/> -->
			<markovJumpsTreeLikelihood idref="${trait}.treeLikelihood"/>
			
		</#list>
			<!-- END Discrete Traits Model                                               -->
		</log>
		
			<!-- write log to file                                                       -->
		<!-- <log id="fileLog_thin" logEvery="2250" fileName="${outputFileStem}.2500.log" overwrite="false">
			<joint idref="joint"/>
			<prior idref="prior"/>
			<likelihood idref="likelihood"/>
			<statistic idref="treeModel.currentTree"/>
		<#list discreteTraits as trait>
		<#assign thisTrait = extractElement(taxaAttributes,trait)>			
			<parameter idref="${trait}.clock.rate"/>
			<parameter idref="${trait}.rates"/>
			<parameter idref="${trait}.indicators"/>
			<sumStatistic idref="${trait}.nonZeroRates"/>
			<parameter idref="${trait}.root.frequencies"/>
			<parameter idref="${trait}.frequencies"/>
			<markovJumpsTreeLikelihood idref="${trait}.treeLikelihood"/>
			
		</#list>
		</log> -->


		<!-- write tree log to file                                                  -->
		<!-- <logTree id="treeFileLog" logEvery="4500" nexusFormat="true" fileName="${outputFileStem}.trees" sortTranslationTable="true">
			<treeModel idref="treeModel"/>
			<trait name="rate" tag="location.rate">
				<strictClockBranchRates idref="location.branchRates"/>
			</trait>
			<joint idref="joint"/>
			
			<#list discreteTraits as trait>
			<trait name="${trait}.states" tag="${trait}">
				<ancestralTreeLikelihood idref="${trait}.treeLikelihood"/>
			</trait>
			</#list>
		</logTree> -->

		<!-- START Ancestral state reconstruction                                    -->

		<!-- write complete history tree log to file                                 -->
		<logTree logEvery="2250" nexusFormat="true" fileName="${outputFileStem}.trees" sortTranslationTable="true">
            <ancestralTraitTreeModel idref="ancestralTraitTreeModel"/>
			<#list discreteTraits as trait>
				<markovJumpsTreeLikelihood idref="${trait}.treeLikelihood"/>
			</#list>
		</logTree>
			<#list discreteTraits as trait>
		<!-- <log id="completeJumpHistorylocation-${trait}" logEvery="2500" fileName="${outputFileStem}.${trait}.completeHistory.log">
            <completeHistoryLogger>
                <markovJumpsTreeLikelihood idref="${trait}.treeLikelihood"/>
            </completeHistoryLogger>
        </log> -->
        	</#list>
		<!-- END Ancestral state reconstruction                                      -->

	</mcmc>
	
	<report>
		<property name="timer">
			<mcmc idref="mcmc"/>
		</property>
	</report>
	
</beast>

	
	
	
	
	
	
